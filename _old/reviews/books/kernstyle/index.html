<!doctype html>
<html lang="en">
<head>
    <title>Linux Kernel Coding Style</title>
    <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <link rel="shortcut icon" href="/assets/img/logo.png" type="image/png">
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <!-- link rel="shortcut icon" href="/assets/img/logo.png" type="image/png"-->
  <link rel="stylesheet" href="/assets/styles.css">
</head>
<body>
<header class=nav-bar>
  <nav>
    <div class=sidebar-button></div>
    <!--div id=bwtoggle></div-->
    <a class="homelink spy" href="/">r<span class=hideable>wx.gg</span></a>
    <div class="nav-right">
      <!-- div id=search-box></div -->
      <ul class=nav-links>
        <li class=nav-item><a class=nav-link href="/boost/">Boosts</a></li>
        <!--
        <li class=nav-item><a class=nav-link href="/how/">HowTos</a></li>
        <li class=nav-item><a class=nav-link href="/contrib/">Contribute</a></li>
        -->
        <li class=nav-item><a class="nav-link" href="https://gitlab.com/rwx.gg/README">GitLab</a></li>
        <li class=nav-item><a class="nav-link" href="https://www.youtube.com/rwxrob">YouTube</a></li>
        <li class=nav-item><a class="nav-link" href="https://discord.gg/9wydZXY">Discord</a></li>
        <li class=nav-item><a class="nav-link" href="https://twitch.tv/rwxrob">Twitch</a></li>
      </ul>
    </div>
  </nav>
</header>
<main id=top>
<div class=container>  <h1 id=title class=duck><a href="https://duckduckgo.com/lite?kae=t&q=Linux Kernel Coding Style">Linux Kernel Coding Style</a></h1>
  <h2 id=subtitle>Linus Torvaldz Original Opinions</h2>
  <p><em>The following was written by Linus Torvaldz as the style guide for the <a href="https://www.kernel.org/doc/html/v4.10/process/coding-style.html">Linux Kernel Project</a>. You probably want to use <a href="/lang/c#rwx-c-coding-style">RWX C coding style</a> instead.</em></p>
  <p>This is a short document describing the preferred coding style for the linux kernel. Coding style is very personal, and I won’t <strong>force</strong> my views on anybody, but this is what goes for anything that I have to be able to maintain, and I’d prefer it for most other things too. Please at least consider the points made here.</p>
  <p>First off, I’d suggest printing out a copy of the GNU coding standards, and NOT read it. Burn them, it’s a great symbolic gesture.</p>
  <p>Anyway, here goes:</p>
  <h2 id="indentation">Indentation</h2>
  <p>Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3.</p>
  <p>Rationale: The whole idea behind indentation is to clearly define where a block of control starts and ends. Especially when you’ve been looking at your screen for 20 straight hours, you’ll find it a lot easier to see how the indentation works if you have large indentations.</p>
  <p>Now, some people will claim that having 8-character indentations makes the code move too far to the right, and makes it hard to read on a 80-character terminal screen. The answer to that is that if you need more than 3 levels of indentation, you’re screwed anyway, and should fix your program.</p>
  <p>In short, 8-char indents make things easier to read, and have the added benefit of warning you when you’re nesting your functions too deep. Heed that warning.</p>
  <p>The preferred way to ease multiple indentation levels in a switch statement is to align the <code>switch</code> and its subordinate <code>case</code> labels in the same column instead of <code>double-indenting</code> the <code>case</code> labels. E.g.:</p>
  <pre class="c"><code>    switch (suffix) {
      case &#39;G&#39;:
      case &#39;g&#39;:
          mem &lt;&lt;= 30;
          break;
      case &#39;M&#39;:
      case &#39;m&#39;:
          mem &lt;&lt;= 20;
          break;
      case &#39;K&#39;:
      case &#39;k&#39;:
          mem &lt;&lt;= 10;
          /* fall through */
      default:
          break;
      }</code></pre>
  <p>Don’t put multiple statements on a single line unless you have something to hide:</p>
  <pre class="c"><code>    if (condition) do_this;
        do_something_everytime;</code></pre>
  <p>Don’t put multiple assignments on a single line either. Kernel coding style is super simple. Avoid tricky expressions.</p>
  <p>Outside of comments, documentation and except in Kconfig, spaces are never used for indentation, and the above example is deliberately broken.</p>
  <p>Get a decent editor and don’t leave whitespace at the end of lines.</p>
  <h2 id="breaking-long-lines-and-strings">Breaking long lines and strings</h2>
  <p>Coding style is all about readability and maintainability using commonly available tools.</p>
  <p>The limit on the length of lines is 80 columns and this is a strongly preferred limit.</p>
  <p>Statements longer than 80 columns will be broken into sensible chunks, unless exceeding 80 columns significantly increases readability and does not hide information. Descendants are always substantially shorter than the parent and are placed substantially to the right. The same applies to function headers with a long argument list. However, never break user-visible strings such as <code>printk</code> messages, because that breaks the ability to grep for them.</p>
  <h2 id="placing-braces-and-spaces">Placing Braces and Spaces</h2>
  <p>The other issue that always comes up in C styling is the placement of braces. Unlike the indent size, there are few technical reasons to choose one placement strategy over the other, but the preferred way, as shown to us by the prophets Kernighan and Ritchie, is to put the opening brace last on the line, and put the closing brace first, thusly:</p>
  <pre class="c"><code>    if (x is true) {
          we do y
      }</code></pre>
  <p>This applies to all non-function statement blocks (<code>if</code>, <code>switch</code>, <code>for</code>, <code>while</code>, <code>do</code>). E.g.:</p>
  <pre class="c"><code>    switch (action) {
      case KOBJ_ADD:
          return &quot;add&quot;;
      case KOBJ_REMOVE:
          return &quot;remove&quot;;
      case KOBJ_CHANGE:
          return &quot;change&quot;;
      default:
          return NULL;
      }</code></pre>
  <p>However, there is one special case, namely functions: they have the opening brace at the beginning of the next line, thus:</p>
  <pre class="c"><code>  int function(int x)
      {
          body of function
      }</code></pre>
  <p>Heretic people all over the world have claimed that this inconsistency is … well … inconsistent, but all right-thinking people know that (a) K&amp;R are <strong>right</strong> and (b) K&amp;R are right. Besides, functions are special anyway (you can’t nest them in C).</p>
  <p>Note that the closing brace is empty on a line of its own, <strong>except</strong> in the cases where it is followed by a continuation of the same statement, ie a <code>while</code> in a do-statement or an <code>else</code> in an if-statement, like this:</p>
  <pre class="c"><code>    do {
          body of do-loop
      } while (condition);</code></pre>
  <p>and</p>
  <pre class="c"><code>    if (x == y) {
          ..
      } else if (x &gt; y) {
          ...
      } else {
          ....
      }</code></pre>
  <p>Rationale: K&amp;R.</p>
  <p>Also, note that this brace-placement also minimizes the number of empty (or almost empty) lines, without any loss of readability. Thus, as the supply of new-lines on your screen is not a renewable resource (think 25-line terminal screens here), you have more empty lines to put comments on.</p>
  <p>Do not unnecessarily use braces where a single statement will do.</p>
  <pre class="c"><code>    if (condition)
          action();</code></pre>
  <p>and</p>
  <pre class="c"><code>    if (condition)
          do_this();
      else
          do_that();</code></pre>
  <p>This does not apply if only one branch of a conditional statement is a single statement; in the latter case use braces in both branches:</p>
  <pre class="c"><code>    if (condition) {
          do_this();
          do_that();
      } else {
          otherwise();
      }</code></pre>
  <h3 id="spaces">Spaces</h3>
  <p>Linux kernel style for use of spaces depends (mostly) on function-versus-keyword usage. Use a space after (most) keywords. The notable exceptions are <code>sizeof</code>,<code>typeof</code>, <code>alignof</code>, and <strong>attribute</strong>, which look somewhat like functions (and are usually used with parentheses in Linux, although they are not required in the language, as in: <code>sizeof info</code> after <code>struct fileinfo info;</code> is declared).</p>
  <p>So use a space after these keywords::</p>
  <pre><code>if, switch, case, for, do, while</code></pre>
  <p>but not with <code>sizeof</code>, <code>typeof</code>, <code>alignof</code>, or <code>__attribute__</code>. E.g.,</p>
  <pre class="c"><code>    s = sizeof(struct file);</code></pre>
  <p>Do not add spaces around (inside) parenthesized expressions. This example is <strong>bad</strong>:</p>
  <pre class="c"><code>    s = sizeof( struct file );</code></pre>
  <p>When declaring pointer data or a function that returns a pointer type, the preferred use of <code>*</code> is adjacent to the data name or function name and not adjacent to the type name. Examples:</p>
  <pre class="c"><code>    char *linux_banner;
      unsigned long long memparse(char *ptr, char **retptr);
      char *match_strdup(substring_t *s);</code></pre>
  <p>Use one space around (on each side of) most binary and ternary operators, such as any of these::</p>
  <pre><code>    =  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</code></pre>
  <p>but no space after unary operators::</p>
  <pre><code>    &amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined</code></pre>
  <p>no space before the postfix increment &amp; decrement unary operators::</p>
  <pre><code>    ++  --</code></pre>
  <p>no space after the prefix increment &amp; decrement unary operators::</p>
  <pre><code>    ++  --</code></pre>
  <p>and no space around the <code>.</code> and <code>-&gt;</code> structure member operators.</p>
  <p>Do not leave trailing whitespace at the ends of lines. Some editors with <code>smart</code> indentation will insert whitespace at the beginning of new lines as appropriate, so you can start typing the next line of code right away. However, some such editors do not remove the whitespace if you end up not putting a line of code there, such as if you leave a blank line. As a result, you end up with lines containing trailing whitespace.</p>
  <p>Git will warn you about patches that introduce trailing whitespace, and can optionally strip the trailing whitespace for you; however, if applying a series of patches, this may make later patches in the series fail by changing their context lines.</p>
  <h2 id="naming">Naming</h2>
  <p>C is a Spartan language, and so should your naming be. Unlike Modula-2 and Pascal programmers, C programmers do not use cute names like <code>ThisVariableIsATemporaryCounter</code>. A C programmer would call that variable <code>tmp</code>, which is much easier to write, and not the least more difficult to understand.</p>
  <p>HOWEVER, while mixed-case names are frowned upon, descriptive names for global variables are a must. To call a global function <code>foo</code> is a shooting offense.</p>
  <p>GLOBAL variables (to be used only if you <strong>really</strong> need them) need to have descriptive names, as do global functions. If you have a function that counts the number of active users, you should call that <code>count_active_users()</code> or similar, you should <strong>not</strong> call it <code>cntusr()</code>.</p>
  <p>Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged — the compiler knows the types anyway and can check those, and it only confuses the programmer. No wonder MicroSoft makes buggy programs.</p>
  <p>LOCAL variable names should be short, and to the point. If you have some random integer loop counter, it should probably be called <code>i</code>. Calling it <code>loop_counter</code> is non-productive, if there is no chance of it being misunderstood. Similarly, <code>tmp</code> can be just about any type of variable that is used to hold a temporary value.</p>
  <p>If you are afraid to mix up your local variable names, you have another problem, which is called the function-growth-hormone-imbalance syndrome. See chapter 6 (Functions).</p>
  <h2 id="typedefs">Typedefs</h2>
  <p>Please don’t use things like <code>vps_t</code>. It’s a <strong>mistake</strong> to use <code>typedef</code> for structures and pointers. When you see a</p>
  <pre class="c"><code>vps_t a;</code></pre>
  <p>in the source, what does it mean? In contrast, if it says</p>
  <pre class="c"><code>struct virtual_container *a;</code></pre>
  <p>you can actually tell what <code>a</code> is.</p>
  <p>Lots of people think that <code>typedef</code>s “help readability”. Not so. They are useful only for:</p>
  <ol type="a">
  <li><p>totally opaque objects (where the <code>typedef</code> is actively used to <strong>hide</strong> what the object is).</p>
  <p>Example: <code>pte_t</code> etc. opaque objects that you can only access using the proper accessor functions.</p>
  <div class="note">
  <p>Opaqueness and <code>accessor functions</code> are not good in themselves. The reason we have them for things like pte_t etc. is that there really is absolutely <strong>zero</strong> portably accessible information there.</p>
  </div></li>
  <li><p>Clear integer types, where the abstraction <strong>helps</strong> avoid confusion whether it is <code>int</code> or <code>long</code>.</p>
  <p><code>u8/u16/u32</code> are perfectly fine <code>typedef</code>s, although they fit into category (d) better than here.</p>
  <div class="note">
  <p>Again - there needs to be a <strong>reason</strong> for this. If something is <code>unsigned long</code>, then there’s no reason to do</p>
  </div>
  <p><code>typedef unsigned long myflags_t;</code></p>
  <p>but if there is a clear reason for why it under certain circumstances might be an <code>unsigned int</code> and under other configurations might be <code>unsigned long</code>, then by all means go ahead and use a typedef.</p></li>
  <li><p>when you use sparse to literally create a <strong>new</strong> type for type-checking.</p></li>
  <li><p>New types which are identical to standard C99 types, in certain exceptional circumstances.</p>
  <p>Although it would only take a short amount of time for the eyes and brain to become accustomed to the standard types like <code>uint32_t</code>, some people object to their use anyway.</p>
  <p>Therefore, the Linux-specific <code>u8/u16/u32/u64</code> types and their signed equivalents which are identical to standard types are permitted – although they are not mandatory in new code of your own.</p>
  <p>When editing existing code which already uses one or the other set of types, you should conform to the existing choices in that code.</p></li>
  <li><p>Types safe for use in userspace.</p>
  <p>In certain structures which are visible to userspace, we cannot require C99 types and cannot use the <code>u32</code> form above. Thus, we use <code>__u32</code> and similar types in all structures which are shared with userspace.</p></li>
  </ol>
  <p>Maybe there are other cases too, but the rule should basically be to NEVER EVER use a typedef unless you can clearly match one of those rules.</p>
  <p>In general, a pointer, or a struct that has elements that can reasonably be directly accessed should <strong>never</strong> be a typedef.</p>
  <h2 id="functions">Functions</h2>
  <p>Functions should be short and sweet, and do just one thing. They should fit on one or two screenfuls of text (the ISO/ANSI screen size is 80 x 24, as we all know), and do one thing and do that well.</p>
  <p>The maximum length of a function is inversely proportional to the complexity and indentation level of that function. So, if you have a conceptually simple function that is just one long (but simple) case-statement, where you have to do lots of small things for a lot of different cases, it’s OK to have a longer function.</p>
  <p>However, if you have a complex function, and you suspect that a less-than-gifted first-year high-school student might not even understand what the function is all about, you should adhere to the maximum limits all the more closely. Use helper functions with descriptive names (you can ask the compiler to in-line them if you think it’s performance-critical, and it will probably do a better job of it than you would have done).</p>
  <p>Another measure of the function is the number of local variables. They shouldn’t exceed 5-10, or you’re doing something wrong. Re-think the function, and split it into smaller pieces. A human brain can generally easily keep track of about 7 different things, anything more and it gets confused. You know you’re brilliant, but maybe you’d like to understand what you did 2 weeks from now.</p>
  <p>In source files, separate functions with one blank line. If the function is exported, the <strong>EXPORT</strong> macro for it should follow immediately after the closing function brace line. E.g.:</p>
  <pre class="c"><code>    int system_is_up(void)
      {
          return system_state == SYSTEM_RUNNING;
      }
      EXPORT_SYMBOL(system_is_up);</code></pre>
  <p>In function prototypes, include parameter names with their data types. Although this is not required by the C language, it is preferred in Linux because it is a simple way to add valuable information for the reader.</p>
  <h2 id="centralized-exiting-of-functions">Centralized exiting of functions</h2>
  <p>Albeit deprecated by some people, the equivalent of the <code>goto</code> statement is used frequently by compilers in form of the unconditional jump instruction.</p>
  <p>The <code>goto</code> statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done. If there is no cleanup needed then just return directly.</p>
  <p>Choose label names which say what the <code>goto</code> does or why the <code>goto</code> exists. An example of a good name could be <code>out_free_buffer:</code> if the <code>goto</code> frees <code>buffer</code>. Avoid using GW-BASIC names like <code>err1:</code> and <code>err2:</code>, as you would have to renumber them if you ever add or remove exit paths, and they make correctness difficult to verify anyway.</p>
  <p>The rationale for using <code>goto</code>s is:</p>
  <ul>
  <li>unconditional statements are easier to understand and follow</li>
  <li>nesting is reduced</li>
  <li>errors by not updating individual exit points when making modifications are prevented</li>
  <li>saves the compiler work to optimize redundant code away ;)</li>
  </ul>
  <pre class="c"><code>    int fun(int a)
      {
          int result = 0;
          char *buffer;

          buffer = kmalloc(SIZE, GFP_KERNEL);
          if (!buffer)
              return -ENOMEM;

          if (condition1) {
              while (loop1) {
                  ...
              }
              result = 1;
              goto out_free_buffer;
          }
          ...
      out_free_buffer:
          kfree(buffer);
          return result;
      }</code></pre>
  <p>A common type of bug to be aware of is <code>one err bugs</code> which look like this:</p>
  <pre class="c"><code>    err:
          kfree(foo-&gt;bar);
          kfree(foo);
          return ret;</code></pre>
  <p>The bug in this code is that on some exit paths <code>foo</code> is NULL. Normally the fix for this is to split it up into two error labels <code>err_free_bar:</code> and <code>err_free_foo:</code>:</p>
  <pre class="c"><code>     err_free_bar:
          kfree(foo-&gt;bar);
       err_free_foo:
          kfree(foo);
          return ret;</code></pre>
  <p>Ideally you should simulate errors to test all exit paths.</p>
  <h2 id="commenting">Commenting</h2>
  <p>Comments are good, but there is also a danger of over-commenting. NEVER try to explain HOW your code works in a comment: it’s much better to write the code so that the <strong>working</strong> is obvious, and it’s a waste of time to explain badly written code.</p>
  <p>Generally, you want your comments to tell WHAT your code does, not HOW. Also, try to avoid putting comments inside a function body: if the function is so complex that you need to separately comment parts of it, you should probably go back to chapter 6 for a while. You can make small comments to note or warn about something particularly clever (or ugly), but try to avoid excess. Instead, put the comments at the head of the function, telling people what it does, and possibly WHY it does it.</p>
  <p>When commenting the kernel API functions, please use the kernel-doc format. See the files at <code>Documentation/doc-guide/ &lt;doc_guide&gt;</code> and <code>scripts/kernel-doc</code> for details.</p>
  <p>The preferred style for long (multi-line) comments is:</p>
  <pre class="c"><code>    /*
       * This is the preferred style for multi-line
       * comments in the Linux kernel source code.
       * Please use it consistently.
       *
       * Description:  A column of asterisks on the left side,
       * with beginning and ending almost-blank lines.
       */</code></pre>
  <p>For files in <code>net/</code> and <code>drivers/net/</code> the preferred style for long (multi-line) comments is a little different.</p>
  <pre class="c"><code>    /* The preferred comment style for files in net/ and drivers/net
       * looks like this.
       *
       * It is nearly the same as the generally preferred comment style,
       * but there is no initial almost-blank line.
       */</code></pre>
  <p>It’s also important to comment data, whether they are basic types or derived types. To this end, use just one data declaration per line (no commas for multiple data declarations). This leaves you room for a small comment on each item, explaining its use.</p>
  <h2 id="youve-made-a-mess-of-it">You’ve made a mess of it</h2>
  <p>That’s OK, we all do. You’ve probably been told by your long-time Unix user helper that <code>GNU emacs</code> automatically formats the C sources for you, and you’ve noticed that yes, it does do that, but the defaults it uses are less than desirable (in fact, they are worse than random typing - an infinite number of monkeys typing into GNU emacs would never make a good program).</p>
  <p>So, you can either get rid of GNU emacs, or change it to use saner values. To do the latter, you can stick the following in your .emacs file:</p>
  <pre><code>  (defun c-lineup-arglist-tabs-only (ignored)
      &quot;Line up argument lists by tabs, not spaces&quot;
      (let* ((anchor (c-langelem-pos c-syntactic-element))
             (column (c-langelem-2nd-pos c-syntactic-element))
             (offset (- (1+ column) anchor))
             (steps (floor offset c-basic-offset)))
        (* (max steps 1)
           c-basic-offset)))

    (add-hook &#39;c-mode-common-hook
              (lambda ()
                ;; Add kernel style
                (c-add-style
                 &quot;linux-tabs-only&quot;
                 &#39;(&quot;linux&quot; (c-offsets-alist
                            (arglist-cont-nonempty
                             c-lineup-gcc-asm-reg
                             c-lineup-arglist-tabs-only))))))

    (add-hook &#39;c-mode-hook
              (lambda ()
                (let ((filename (buffer-file-name)))
                  ;; Enable kernel mode for the appropriate files
                  (when (and filename
                             (string-match (expand-file-name &quot;~/src/linux-trees&quot;)
                                           filename))
                    (setq indent-tabs-mode t)
                    (setq show-trailing-whitespace t)
                    (c-set-style &quot;linux-tabs-only&quot;)))))</code></pre>
  <p>This will make emacs go better with the kernel coding style for C files below <code>~/src/linux-trees</code>.</p>
  <p>But even if you fail in getting emacs to do sane formatting, not everything is lost: use <code>indent</code>.</p>
  <p>Now, again, GNU indent has the same brain-dead settings that GNU emacs has, which is why you need to give it a few command line options. However, that’s not too bad, because even the makers of GNU indent recognize the authority of K&amp;R (the GNU people aren’t evil, they are just severely misguided in this matter), so you just give indent the options <code>-kr -i8</code> (stands for <code>K&amp;R, 8 character indents</code>), or use <code>scripts/Lindent</code>, which indents in the latest style.</p>
  <p><code>indent</code> has a lot of options, and especially when it comes to comment re-formatting you may want to take a look at the man page. But remember: <code>indent</code> is not a fix for bad programming.</p>
  <h2 id="kconfig-configuration-files">Kconfig configuration files</h2>
  <p>For all of the Kconfig* configuration files throughout the source tree, the indentation is somewhat different. Lines under a <code>config</code> definition are indented with one tab, while help text is indented an additional two spaces. Example::</p>
  <pre><code>  config AUDIT
      bool &quot;Auditing support&quot;
      depends on NET
      help
        Enable auditing infrastructure that can be used with another
        kernel subsystem, such as SELinux (which requires this for
        logging of avc messages output).  Does not do system-call
        auditing without CONFIG_AUDITSYSCALL.</code></pre>
  <p>Seriously dangerous features (such as write support for certain filesystems) should advertise this prominently in their prompt string::</p>
  <pre><code>  config ADFS_FS_RW
      bool &quot;ADFS write support (DANGEROUS)&quot;
      depends on ADFS_FS
      ...</code></pre>
  <p>For full documentation on the configuration files, see the file <code>Documentation/kbuild/kconfig-language.txt</code>.</p>
  <h2 id="data-structures">Data structures</h2>
  <p>Data structures that have visibility outside the single-threaded environment they are created and destroyed in should always have reference counts. In the kernel, garbage collection doesn’t exist (and outside the kernel garbage collection is slow and inefficient), which means that you absolutely <strong>have</strong> to reference count all your uses.</p>
  <p>Reference counting means that you can avoid locking, and allows multiple users to have access to the data structure in parallel - and not having to worry about the structure suddenly going away from under them just because they slept or did something else for a while.</p>
  <p>Note that locking is <strong>not</strong> a replacement for reference counting. Locking is used to keep data structures coherent, while reference counting is a memory management technique. Usually both are needed, and they are not to be confused with each other.</p>
  <p>Many data structures can indeed have two levels of reference counting, when there are users of different <code>classes</code>. The subclass count counts the number of subclass users, and decrements the global count just once when the subclass count goes to zero.</p>
  <p>Examples of this kind of <code>multi-level-reference-counting</code> can be found in memory management (<code>struct mm_struct</code>: mm_users and mm_count), and in filesystem code (<code>struct super_block</code>: s_count and s_active).</p>
  <p>Remember: if another thread can find your data structure, and you don’t have a reference count on it, you almost certainly have a bug.</p>
  <h2 id="macros-enums-and-rtl">Macros, Enums and RTL</h2>
  <p>Names of macros defining constants and labels in enums are capitalized.</p>
  <pre class="c"><code>    #define CONSTANT 0x12345</code></pre>
  <p>Enums are preferred when defining several related constants.</p>
  <p>CAPITALIZED macro names are appreciated but macros resembling functions may be named in lower case.</p>
  <p>Generally, inline functions are preferable to macros resembling functions.</p>
  <p>Macros with multiple statements should be enclosed in a do - while block:</p>
  <pre class="c"><code>    #define macrofun(a, b, c)           \
          do {                    \
              if (a == 5)         \
                  do_this(b, c);      \
          } while (0)</code></pre>
  <p>Things to avoid when using macros:</p>
  <ol type="1">
  <li>macros that affect control flow:</li>
  </ol>
  <pre class="c"><code>    #define FOO(x)                  \
          do {                    \
              if (blah(x) &lt; 0)        \
                  return -EBUGGERED;  \
          } while (0)</code></pre>
  <p>is a <strong>very</strong> bad idea. It looks like a function call but exits the <code>calling</code> function; don’t break the internal parsers of those who will read the code.</p>
  <ol start="2" type="1">
  <li>macros that depend on having a local variable with a magic name:</li>
  </ol>
  <pre class="c"><code>    #define FOO(val) bar(index, val)</code></pre>
  <p>might look like a good thing, but it’s confusing as hell when one reads the code and it’s prone to breakage from seemingly innocent changes.</p>
  <ol start="3" type="1">
  <li><p>macros with arguments that are used as <code>FOO(x) = y</code>; will bite you if somebody e.g. turns FOO into an inline function.</p></li>
  <li><p>forgetting about precedence: macros defining constants using expressions must enclose the expression in parentheses. Beware of similar issues with macros using parameters.</p></li>
  </ol>
  <pre class="c"><code>    #define CONSTANT 0x4000
      #define CONSTEXP (CONSTANT | 3)</code></pre>
  <ol start="5" type="1">
  <li>namespace collisions when defining local variables in macros resembling functions:</li>
  </ol>
  <pre class="c"><code>    #define FOO(x)              \
      ({                  \
          typeof(x) ret;          \
          ret = calc_ret(x);      \
          (ret);              \
      })</code></pre>
  <p><code>ret</code> is a common name for a local variable — <code>__foo_ret</code> is less likely to collide with an existing variable.</p>
  <p>The CPP manual deals with macros exhaustively. The <code>gcc</code> internals manual also covers RTL which is used frequently with assembly language in the kernel.</p>
  <h2 id="printing-kernel-messages">Printing kernel messages</h2>
  <p>Kernel developers like to be seen as literate. Do mind the spelling of kernel messages to make a good impression. Do not use crippled words like <code>dont</code>; use <code>do not</code> or <code>don't</code> instead. Make the messages concise, clear, and unambiguous.</p>
  <p>Kernel messages do not have to be terminated with a period.</p>
  <p>Printing numbers in parentheses (%d) adds no value and should be avoided.</p>
  <p>There are a number of driver model diagnostic macros in <code>&lt;linux/device.h&gt;</code> which you should use to make sure messages are matched to the right device and driver, and are tagged with the right level: <code>dev_err()</code>, <code>dev_warn()</code>, <code>dev_info()</code>, and so forth. For messages that aren’t associated with a particular device, <code>&lt;linux/printk.h&gt;</code> defines <code>pr_notice()</code>, <code>pr_info()</code>, <code>pr_warn()</code>, <code>pr_err()</code>, etc.</p>
  <p>Coming up with good debugging messages can be quite a challenge; and once you have them, they can be a huge help for remote troubleshooting. However debug message printing is handled differently than printing other non-debug messages. While the other <code>pr_XXX()</code> functions print unconditionally, <code>pr_debug()</code> does not; it is compiled out by default, unless either <code>DEBUG</code> is defined or <code>CONFIG_DYNAMIC_DEBUG</code> is set. That is true for <code>dev_dbg()</code> also, and a related convention uses <code>VERBOSE_DEBUG</code> to add <code>dev_vdbg()</code> messages to the ones already enabled by <code>DEBUG</code>.</p>
  <p>Many subsystems have Kconfig debug options to turn on <code>-DDEBUG</code> in the corresponding Makefile; in other cases specific files <code>#define DEBUG</code>. And when a debug message should be unconditionally printed, such as if it is already inside a debug-related <code>#ifdef</code> section, <code>printk(KERN_DEBUG ...)</code> can be used.</p>
  <h2 id="allocating-memory">Allocating memory</h2>
  <p>The kernel provides the following general purpose memory allocators: <code>kmalloc()</code>, <code>kzalloc()</code>, <code>kmalloc_array()</code>, <code>kcalloc()</code>, <code>vmalloc()</code>, and <code>vzalloc()</code>. Please refer to the API documentation for further information about them.</p>
  <p>The preferred form for passing a size of a struct is the following:</p>
  <pre class="c"><code>    p = kmalloc(sizeof(*p), ...);</code></pre>
  <p>The alternative form where struct name is spelled out hurts readability and introduces an opportunity for a bug when the pointer variable type is changed but the corresponding <code>sizeof</code> that is passed to a memory allocator is not.</p>
  <p>Casting the return value which is a void pointer is redundant. The conversion from void pointer to any other pointer type is guaranteed by the C programming language.</p>
  <p>The preferred form for allocating an array is the following:</p>
  <pre class="c"><code>    p = kmalloc_array(n, sizeof(...), ...);</code></pre>
  <p>The preferred form for allocating a zeroed array is the following:</p>
  <pre class="c"><code>    p = kcalloc(n, sizeof(...), ...);</code></pre>
  <p>Both forms check for overflow on the allocation <code>size n * sizeof(...)</code>, and return <code>NULL</code> if that occurred.</p>
  <h2 id="the-inline-disease">The inline disease</h2>
  <p>There appears to be a common misperception that <code>gcc</code> has a magic “make me faster” speedup option called <code>inline</code>. While the use of <code>inlines</code> can be appropriate (for example as a means of replacing macros, see Chapter 12), it very often is not. Abundant use of the inline keyword leads to a much bigger kernel, which in turn slows the system as a whole down, due to a bigger <code>icache</code> footprint for the CPU and simply because there is less memory available for the <code>pagecache</code>. Just think about it; a <code>pagecache</code> miss causes a disk seek, which easily takes 5 milliseconds. There are a LOT of CPU cycles that can go into these 5 milliseconds.</p>
  <p>A reasonable rule of thumb is to not put inline at functions that have more than 3 lines of code in them. An exception to this rule are the cases where a parameter is known to be a <code>compiletime</code> constant, and as a result of this constantness you <em>know</em> the compiler will be able to optimize most of your function away at compile time. For a good example of this later case, see the <code>kmalloc()</code> inline function.</p>
  <p>Often people argue that adding inline to functions that are static and used only once is always a win since there is no space trade-off. While this is technically correct, <code>gcc</code> is capable of inlining these automatically without help, and the maintenance issue of removing the inline when a second user appears outweighs the potential value of the hint that tells <code>gcc</code> to do something it would have done anyway.</p>
  <h2 id="function-return-values-and-names">Function return values and names</h2>
  <p>Functions can return values of many different kinds, and one of the most common is a value indicating whether the function succeeded or failed. Such a value can be represented as an error-code integer (<code>-Exxx = failure, 0 = success</code>) or a <code>succeeded</code> boolean (0 = failure, non-zero = success).</p>
  <p>Mixing up these two sorts of representations is a fertile source of difficult-to-find bugs. If the C language included a strong distinction between integers and booleans then the compiler would find these mistakes for us… but it doesn’t. To help prevent such bugs, always follow this convention::</p>
  <pre><code>If the name of a function is an action or an imperative command,
  the function should return an error-code integer.  If the name
  is a predicate, the function should return a &quot;succeeded&quot; boolean.</code></pre>
  <p>For example, <code>add work</code> is a command, and the add_work() function returns 0 for success or <code>-EBUSY</code> for failure. In the same way, <code>PCI device present</code> is a predicate, and the <code>pci_dev_present()</code> function returns 1 if it succeeds in finding a matching device or 0 if it doesn’t.</p>
  <p>All <code>EXPORT</code>ed functions must respect this convention, and so should all public functions. Private (static) functions need not, but it is recommended that they do.</p>
  <p>Functions whose return value is the actual result of a computation, rather than an indication of whether the computation succeeded, are not subject to this rule. Generally they indicate failure by returning some out-of-range result. Typical examples would be functions that return pointers; they use <code>NULL</code> or the <code>ERR_PTR</code> mechanism to report failure.</p>
  <h2 id="dont-re-invent-the-kernel-macros">Don’t re-invent the kernel macros</h2>
  <p>The header file <code>include/linux/kernel.h</code> contains a number of macros that you should use, rather than explicitly coding some variant of them yourself. For example, if you need to calculate the length of an array, take advantage of the macro</p>
  <pre class="c"><code>#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</code></pre>
  <p>Similarly, if you need to calculate the size of some structure member, use</p>
  <pre class="c"><code>#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</code></pre>
  <p>There are also <code>min()</code> and <code>max()</code> macros that do strict type checking if you need them. Feel free to peruse that header file to see what else is already defined that you shouldn’t reproduce in your code.</p>
  <h2 id="editor-modelines-and-other-cruft">Editor <code>modelines</code> and other cruft</h2>
  <p>Some editors can interpret configuration information embedded in source files, indicated with special markers. For example, emacs interprets lines marked like this:</p>
  <pre class="c"><code>    -*- mode: c -*-</code></pre>
  <p>Or like this:</p>
  <pre class="c"><code>/*
  Local Variables:
  compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;
  End:
  */</code></pre>
  <p>Vim interprets markers that look like this:</p>
  <pre class="c"><code>/* vim:set sw=8 noet */</code></pre>
  <p>Do not include any of these in source files. People have their own personal editor configurations, and your source files should not override them. This includes markers for indentation and mode configuration. People may use their own custom mode, or may have some other magic method for making indentation work correctly.</p>
  <h2 id="inline-assembly">Inline assembly</h2>
  <p>In architecture-specific code, you may need to use inline assembly to interface with CPU or platform functionality. Don’t hesitate to do so when necessary. However, don’t use inline assembly gratuitously when C can do the job. You can and should poke hardware from C when possible.</p>
  <p>Consider writing simple helper functions that wrap common bits of inline assembly, rather than repeatedly writing them with slight variations. Remember that inline assembly can use C parameters.</p>
  <p>Large, non-trivial assembly functions should go in .S files, with corresponding C prototypes defined in C header files. The C prototypes for assembly functions should use <code>asmlinkage</code>.</p>
  <p>You may need to mark your <code>asm</code> statement as volatile, to prevent GCC from removing it if GCC doesn’t notice any side effects. You don’t always need to do so, though, and doing so unnecessarily can limit optimization.</p>
  <p>When writing a single inline assembly statement containing multiple instructions, put each instruction on a separate line in a separate quoted string, and end each string except the last with  properly indent the next instruction in the assembly output:</p>
  <pre class="c"><code>    asm (&quot;magic %reg1, #42\n\t&quot;
           &quot;more_magic %reg2, %reg3&quot;
           : /* outputs */ : /* inputs */ : /* clobbers */);</code></pre>
  <h2 id="conditional-compilation">Conditional Compilation</h2>
  <p>Wherever possible, don’t use preprocessor conditionals (<code>#if</code>, <code>#ifdef</code>) in <code>.c</code> files; doing so makes code harder to read and logic harder to follow. Instead, use such conditionals in a header file defining functions for use in those <code>.c</code> files, providing no-op stub versions in the <code>#else</code> case, and then call those functions unconditionally from <code>.c</code> files. The compiler will avoid generating any code for the stub calls, producing identical results, but the logic will remain easy to follow.</p>
  <p>Prefer to compile out entire functions, rather than portions of functions or portions of expressions. Rather than putting an <code>ifdef</code> in an expression, factor out part or all of the expression into a separate helper function and apply the conditional to that function.</p>
  <p>If you have a function or variable which may potentially go unused in a particular configuration, and the compiler would warn about its definition going unused, mark the definition as <strong>maybe</strong>unused rather than wrapping it in a preprocessor conditional. (However, if a function or variable <em>always</em> goes unused, delete it.)</p>
  <p>Within code, where possible, use the IS_ENABLED macro to convert a Kconfig symbol into a C boolean expression, and use it in a normal C conditional:</p>
  <pre class="c"><code>    if (IS_ENABLED(CONFIG_SOMETHING)) {
          ...
      }</code></pre>
  <p>The compiler will constant-fold the conditional away, and include or exclude the block of code just as with an <code>#ifdef</code>, so this will not add any runtime overhead. However, this approach still allows the C compiler to see the code inside the block, and check it for correctness (syntax, types, symbol references, etc). Thus, you still have to use an <code>#ifdef</code> if the code inside the block references symbols that will not exist if the condition is not met.</p>
  <p>At the end of any non-trivial <code>#if</code> or <code>#ifdef</code> block (more than a few lines), place a comment after the <code>#endif</code> on the same line, noting the conditional expression used. For instance:</p>
  <pre class="c"><code>    #ifdef CONFIG_SOMETHING
      ...
      #endif /* CONFIG_SOMETHING */</code></pre>
  <h2 id="appendix-i-references">Appendix I) References</h2>
  <p>The C Programming Language, Second Edition by Brian W. Kernighan and Dennis M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback).</p>
  <p>The Practice of Programming by Brian W. Kernighan and Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.</p>
  <p>GNU manuals - where in compliance with K&amp;R and this text - for cpp, gcc, gcc internals and indent, all available from http://www.gnu.org/manual/</p>
  <p>WG14 is the international standardization working group for the programming language C, URL: http://www.open-std.org/JTC1/SC22/WG14/</p>
  <p>Kernel process/coding-style.rst, by greg@kroah.com at OLS 2002: http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</p>
</main>
<footer>
  <p><a href="/copyright/" id=copyright>© 2020 Rob Muhlestein. Licensed under Creative Commons Attribution-ShareAlike.</a><br/>Does something seem to have changed? <a href="/changes/">Check the change log</a>.
  <br>See something wrong? <a class="nodecor" href="https://gitlab.com/rwx.gg/README/-/issues">Open a ticket</a>.
  </p>
</footer>
<script src="/assets/main.js"></script>
</body>
</html>